const d="End-Of-Stream";class i extends Error{constructor(){super(d),this.name="EndOfStreamError"}}class u extends Error{constructor(e="The operation was aborted"){super(e),this.name="AbortError"}}class o{constructor(){this.endOfStream=!1,this.interrupted=!1,this.peekQueue=[]}async peek(e,t=!1){const r=await this.read(e,t);return this.peekQueue.push(e.subarray(0,r)),r}async read(e,t=!1){if(e.length===0)return 0;let r=this.readFromPeekBuffer(e);if(this.endOfStream||(r+=await this.readRemainderFromStream(e.subarray(r),t)),r===0)throw new i;return r}readFromPeekBuffer(e){let t=e.length,r=0;for(;this.peekQueue.length>0&&t>0;){const a=this.peekQueue.pop();if(!a)throw new Error("peekData should be defined");const n=Math.min(a.length,t);e.set(a.subarray(0,n),r),r+=n,t-=n,n<a.length&&this.peekQueue.push(a.subarray(n))}return r}async readRemainderFromStream(e,t){let r=0;for(;r<e.length&&!this.endOfStream;){if(this.interrupted)throw new u;const a=await this.readFromStream(e.subarray(r),t);if(a===0)break;r+=a}if(!t&&r<e.length)throw new i;return r}}class l extends o{constructor(e){super(),this.reader=e}async abort(){return this.close()}async close(){this.reader.releaseLock()}}class c extends l{async readFromStream(e,t){if(e.length===0)return 0;const r=await this.reader.read(new Uint8Array(e.length),{min:t?void 0:e.length});return r.done&&(this.endOfStream=r.done),r.value?(e.set(r.value),r.value.length):0}}class h extends o{constructor(e){super(),this.reader=e,this.buffer=null}writeChunk(e,t){const r=Math.min(t.length,e.length);return e.set(t.subarray(0,r)),r<t.length?this.buffer=t.subarray(r):this.buffer=null,r}async readFromStream(e,t){if(e.length===0)return 0;let r=0;for(this.buffer&&(r+=this.writeChunk(e,this.buffer));r<e.length&&!this.endOfStream;){const a=await this.reader.read();if(a.done){this.endOfStream=!0;break}a.value&&(r+=this.writeChunk(e.subarray(r),a.value))}if(r===0&&this.endOfStream)throw new i;return r}abort(){return this.interrupted=!0,this.reader.cancel()}async close(){await this.abort(),this.reader.releaseLock()}}function m(s){try{const e=s.getReader({mode:"byob"});return e instanceof ReadableStreamDefaultReader?new h(e):new c(e)}catch(e){if(e instanceof TypeError)return new h(s.getReader());throw e}}export{i as E,m};
