import{E as i,m as h}from"./peek-readable-BVp5v6zA.js";class f{constructor(e){this.numBuffer=new Uint8Array(8),this.position=0,this.onClose=e==null?void 0:e.onClose,e!=null&&e.abortSignal&&e.abortSignal.addEventListener("abort",()=>{this.abort()})}async readToken(e,t=this.position){const r=new Uint8Array(e.len);if(await this.readBuffer(r,{position:t})<e.len)throw new i;return e.get(r,0)}async peekToken(e,t=this.position){const r=new Uint8Array(e.len);if(await this.peekBuffer(r,{position:t})<e.len)throw new i;return e.get(r,0)}async readNumber(e){if(await this.readBuffer(this.numBuffer,{length:e.len})<e.len)throw new i;return e.get(this.numBuffer,0)}async peekNumber(e){if(await this.peekBuffer(this.numBuffer,{length:e.len})<e.len)throw new i;return e.get(this.numBuffer,0)}async ignore(e){if(this.fileInfo.size!==void 0){const t=this.fileInfo.size-this.position;if(e>t)return this.position+=t,t}return this.position+=e,e}async close(){var e;await this.abort(),await((e=this.onClose)==null?void 0:e.call(this))}normalizeOptions(e,t){if(!this.supportsRandomAccess()&&t&&t.position!==void 0&&t.position<this.position)throw new Error("`options.position` must be equal or greater than `tokenizer.position`");return{mayBeLess:!1,offset:0,length:e.length,position:this.position,...t}}abort(){return Promise.resolve()}}const u=256e3;class c extends f{constructor(e,t){super(t),this.streamReader=e,this.fileInfo=(t==null?void 0:t.fileInfo)??{}}async readBuffer(e,t){const r=this.normalizeOptions(e,t),s=r.position-this.position;if(s>0)return await this.ignore(s),this.readBuffer(e,t);if(s<0)throw new Error("`options.position` must be equal or greater than `tokenizer.position`");if(r.length===0)return 0;const n=await this.streamReader.read(e.subarray(0,r.length),r.mayBeLess);if(this.position+=n,(!t||!t.mayBeLess)&&n<r.length)throw new i;return n}async peekBuffer(e,t){const r=this.normalizeOptions(e,t);let s=0;if(r.position){const n=r.position-this.position;if(n>0){const o=new Uint8Array(r.length+n);return s=await this.peekBuffer(o,{mayBeLess:r.mayBeLess}),e.set(o.subarray(n)),s-n}if(n<0)throw new Error("Cannot peek from a negative offset in a stream")}if(r.length>0){try{s=await this.streamReader.peek(e.subarray(0,r.length),r.mayBeLess)}catch(n){if(t!=null&&t.mayBeLess&&n instanceof i)return 0;throw n}if(!r.mayBeLess&&s<r.length)throw new i}return s}async ignore(e){const t=Math.min(u,e),r=new Uint8Array(t);let s=0;for(;s<e;){const n=e-s,o=await this.readBuffer(r,{length:Math.min(t,n)});if(o<0)return o;s+=o}return s}abort(){return this.streamReader.abort()}async close(){return this.streamReader.close()}supportsRandomAccess(){return!1}}class l extends f{constructor(e,t){super(t),this.uint8Array=e,this.fileInfo={...(t==null?void 0:t.fileInfo)??{},size:e.length}}async readBuffer(e,t){t!=null&&t.position&&(this.position=t.position);const r=await this.peekBuffer(e,t);return this.position+=r,r}async peekBuffer(e,t){const r=this.normalizeOptions(e,t),s=Math.min(this.uint8Array.length-r.position,r.length);if(!r.mayBeLess&&s<r.length)throw new i;return e.set(this.uint8Array.subarray(r.position,r.position+s)),s}close(){return super.close()}supportsRandomAccess(){return!0}setPosition(e){this.position=e}}function w(a,e){const t=h(a),r=e??{},s=r.onClose;return r.onClose=async()=>{if(await t.close(),s)return s()},new c(t,r)}function y(a,e){return new l(a,e)}export{w as a,y as f};
